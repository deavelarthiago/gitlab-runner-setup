##################################################################################################

**gitlab-runner-setup**

##################################################################################################


Purpose:
This Terraform project automatically configures an instance on AWS to be used as a GitLab Runner. This setup includes the installation of Docker, registering the runner with GitLab, and initial configuration for pipeline execution, making it ready to run Docker jobs.

Prerequisites:
- Terraform v0.12.x or higher;
- AWS account with access configured in your development environment;
- SSH key created on AWS for access to EC2 instances;
- GitLab Runner registration token.

Created Resources:
- EC2 Instance: A virtual machine on AWS configured to host the GitLab Runner. The instance is specified based on the instance type, AMI image, SSH key and other parameters defined in the project variables;
- Docker: Docker is installed on the EC2 instance, enabling the GitLab Runner to execute jobs in containers;
- GitLab Runner Registration: The initialization script (user_data) automates the registration of the runner with a GitLab instance using a provided registration token, allowing it to start processing jobs immediately after installation;
- CloudWatch Log: Configuration of a log group in CloudWatch and a log stream to capture and store logs generated by the GitLab Runner, facilitating monitoring and debugging.

To register a new runner:
A new token must be generated in GitLab and subsequently inserted into the `user_data` of the `main.tf` file in the field `--registration-token` on `line 27`.

The structure of this code should be as follows:
--registration-token "your-new-gitlab-runner-token".

Before using the provided code, consider following the best practice of managing the Terraform backend. This ensures that the infrastructure is managed consistently and securely, especially in collaborative environments where multiple people or teams may be configuring resources simultaneously. With a centralized and versioned tfstate, conflicts and errors from outdated states are avoided, and auditing and restoring previous versions become possible, increasing the reliability and transparency of the entire operation.

To implement this practice efficiently, the detailed procedure was in the following project, which provides a backend configuration using S3 as an example:

https://github.com/deavelarthiago/terraform-projects/tree/master/terraform-s3-backend-management

This process provides a solid foundation to ensure shared and protected state, preparing the environment for the safe and organized execution of other projects.